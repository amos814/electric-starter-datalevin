{"version":3,"sources":["hyperfiddle/electric/impl/yield2.cljc"],"mappings":"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","names":["hyperfiddle.electric.impl.yield2/input","hyperfiddle.electric.impl.yield2/recover","hyperfiddle.electric.impl.yield2/children","hyperfiddle.electric.impl.yield2/last-in","hyperfiddle.electric.impl.yield2/last-out","unused__11938__auto__","self__","G__43528","js/Error","args43527","cljs.core/aclone","this__5330__auto__","writer__5331__auto__","opt__5332__auto__","cljs.core/-write","hyperfiddle.electric.impl.yield2/Yield","hyperfiddle.electric.impl.yield2/->Yield","checker","notifier","terminator","state-","this","hyperfiddle.electric.impl.yield2/cancel","hyperfiddle.electric.impl.yield2/transfer","hyperfiddle.electric.impl.yield2/iterator","hyperfiddle.electric.impl.yield2/notified?","hyperfiddle.electric.impl.yield2/on-notify","hyperfiddle.electric.impl.yield2/input-notified","Y","or__5045__auto__","hyperfiddle.electric.impl.array-fields/getset","hyperfiddle.electric.impl.array-fields/get","G__43534","fexpr__43535","hyperfiddle.electric.impl.yield2/recover-notified","fexpr__43536","hyperfiddle.electric.impl.yield2/terminated","hyperfiddle.electric.impl.array_fields.swap","cljs.core/dec","fexpr__43537","hyperfiddle.electric.impl.yield2/swallow","o","cljs.core/deref","e43538","_","hyperfiddle.electric.impl.yield2/trash","arr43539","cljs.core/identity","fexpr__43540","fexpr__43542","temp__5808__auto__","rec","hyperfiddle.electric.impl.yield2/create-recover",">r","cljs.core/inc","me","arr43553","cljs.core.object_array","arr43554","arr43555","G__43556","G__43557","fexpr__43558","hyperfiddle.electric.impl.yield2/transfer-loop","arr43559","v","hyperfiddle.electric.impl.yield2/transfer-recover","arr43561","hyperfiddle.electric.impl.yield2/transfer-input","in","cljs.core._EQ_","G__43563","temp__5806__auto__",">recover","fexpr__43567","out","arr43569","arr43570","arr43568","e43575","cljs.core.ex_info","e","hyperfiddle.electric.impl.yield2/yield",">input","n","t","arr43580","arr43581","G__43582","G__43583","fexpr__43584"],"sourcesContent":["(ns hyperfiddle.electric.impl.yield2\n  #?(:cljs (:require-macros hyperfiddle.electric.impl.yield2))\n  (:import [missionary Cancelled]\n           #?(:clj [clojure.lang IFn IDeref ExceptionInfo]))\n  (:require [hyperfiddle.rcf :as rcf :refer [tests tap %]]\n            [hyperfiddle.electric.impl.array-fields :as a]\n            [missionary.core :as m]))\n;; #?(:clj (set! *warn-on-reflection* true))\n(declare cancel transfer)\n(a/deffields input recover children last-in last-out) ; Yield's array fields\n(deftype Yield [checker notifier terminator state-]\n  IFn (#?(:clj invoke :cljs -invoke) [this] (locking this (cancel this)))\n  IDeref (#?(:clj deref :cljs -deref) [this] (locking this (transfer this))))\n(a/deffields iterator notified? on-notify) ; a child's array fields\n(defn input-notified [^Yield Y]\n  (when-not (or (a/getset (a/fget Y input) notified? true) (some-> (a/fget Y recover) (a/get notified?)))\n    ((.-notifier Y))))\n(defn recover-notified [^Yield Y]\n  (when-not (or (a/getset (a/fget Y recover) notified? true) (a/get (a/fget Y input) notified?))\n    ((.-notifier Y))))\n(defn terminated [^Yield Y] (when (zero? (a/fswap Y children dec)) ((.-terminator Y))))\n(defn swallow [o] (try @(a/get o iterator) (catch #?(:clj Throwable :cljs :default) _)))\n(defn trash [o] (a/set o on-notify #(swallow o)) ((a/get o iterator)) (when (a/getset o notified? false) (swallow o)))\n(defn cancel [^Yield Y] ((a/get (a/fget Y input) iterator)) (when-some [rec (a/fget Y recover)] (trash rec)))\n(defn create-recover [^Yield Y >r]\n  (when-some [rec (a/fget Y recover)] (trash rec))\n  (a/fswap Y children inc)\n  (let [me (a/fset Y recover (object-array 3))]\n    (a/set me on-notify #(a/set me notified? true), iterator (>r #((a/get me on-notify)) #(terminated Y)))))\n(defn transfer-loop [o] (a/set o notified? false) (let [v @(a/get o iterator)] (if (a/get o notified?) (recur o) v)))\n(defn transfer-recover [^Yield Y] (a/fset Y last-out (transfer-loop (a/fget Y recover))))\n(defn transfer-input [^Yield Y]\n  (let [in (transfer-loop (a/fget Y input))]\n    (if (= in (a/fget Y last-in))\n      (if (some-> (a/fget Y recover) (a/get notified?))\n        (transfer-recover Y)\n        (a/fget Y last-out))\n      (if-some [>recover ((.-checker Y) in)]\n        (let [out (do (create-recover Y >recover) (transfer-recover Y))]\n          (a/set (a/fget Y recover) on-notify #(recover-notified Y))\n          (a/fset Y last-in in, last-out out))\n        (do (a/fset Y last-in ::none) (when-some [rec (a/fget Y recover)] (trash rec))  in)))))\n(defn transfer [^Yield Y]\n  (try (a/fswap Y children inc)\n       (cond (a/get (a/fget Y input)   notified?) (transfer-input Y)\n             (a/get (a/fget Y recover) notified?) (transfer-recover Y)\n             :else (throw (ex-info \"You cannot transfer a value if I haven't notified you\" {})))\n       (catch #?(:clj Throwable :cljs :default) e\n         (trash (a/fget Y input)) (when-some [rec (a/fget Y recover)] (trash rec)) (throw e))\n       (finally (terminated Y))))\n(defn yield [checker >input]\n  (fn [n t]\n    (let [^Yield Y (->Yield checker n t (object-array 5))\n          me (a/fset Y children 1, last-in ::none, input (object-array 3))]\n      (a/set me on-notify #(input-notified Y), iterator (>input #((a/get me on-notify)) #(terminated Y)))\n      Y)))\n;;; TESTS ;;;\n(tests \"input flow with nil checker is noop\"\n  (def !x (atom 0))\n  (def it ((yield (constantly nil) (m/watch !x))\n           #(tap :notified) #(tap :terminated)))\n  #_start         % := :notified, @it := 0\n  (swap! !x inc)  % := :notified, @it := 1\n  (swap! !x inc)  % := :notified, @it := 2\n  (it)            % := :notified, @it :throws Cancelled, % := :terminated)\n(tests \"input flow runs recovery\"\n  (def !x (atom 0))\n  (def !recover (atom 10))\n  (def it ((yield (constantly (m/watch !recover)) (m/watch !x))  #(tap :notified) #(tap :terminated)))\n  #_start               % := :notified, @it := 10\n  (swap! !x inc)        % := :notified, @it := 10\n  (swap! !recover inc)  % := :notified, @it := 11\n  (it)                  % := :notified, @it :throws Cancelled, % := :terminated)\n(tests \"oscillate\"\n  (def !e (atom \"odd\"))\n  (def !x (atom 0))\n  (def it ((yield (fn [x] (when (odd? x) (m/watch !e))) (m/watch !x))  #(do) #(do)))\n  #_start            @it := 0\n  (swap! !x inc)     @it := \"odd\"\n  (reset! !e \"ODD\")  @it := \"ODD\"\n  (swap! !x inc)     @it := 2\n  (it))\n(tests \"work skipping\"\n  (def !e (atom \"odd\"))\n  (def !x (atom 0))\n  (def it ((yield (fn [x] (tap x) (when (odd? x) (m/watch !e))) (m/watch !x))  #(do) #(do)))\n  #_start             @it := 0,     % := 0\n  (swap! !x inc)      @it := \"odd\", % := 1\n  (swap! !x identity) @it := \"odd\"    ; nothing tapped, work skipped\n  (reset! !e \"ODD\")   @it := \"ODD\"    ; recovery flow is still alive\n  (swap! !x inc)      @it := 2,     % := 2\n  (it))\n(tests \"work skipping, initially in recovery\"\n  (def !e (atom \"odd\"))\n  (def !x (atom 1))\n  (def it ((yield (fn [x] (tap x) (when (odd? x) (m/watch !e))) (m/watch !x))  #(do) #(do)))\n  #_start             @it := \"odd\", % := 1\n  (swap! !x identity) @it := \"odd\"    ; nothing tapped, work skipped\n  (reset! !e \"ODD\")   @it := \"ODD\"    ; recovery flow is still alive\n  (swap! !x inc)      @it := 2,     % := 2\n  (it))\n(tests \"work skipping m/cp\"\n  (def !x (atom 1))\n  (def it ((yield (fn [x] (tap x) (when (odd? x) (m/cp \"odd\"))) (m/watch !x))  #(do) #(do)))\n  #_start             @it := \"odd\", % := 1\n  (swap! !x identity) @it := \"odd\"    ; nothing tapped, work skipped\n  (swap! !x inc)      @it := 2,     % := 2\n  (it))\n(tests \"recovery flows are cleaned up\"\n  (def !x (atom 0))\n  (let [->recover (m/observe (fn [!] (! :init) #(tap :unmounted)))]\n    (def it ((yield (fn [x] (when (pos? x) ->recover)) (m/watch !x))  #(do) #(tap :terminated))))\n  #_start         @it := 0\n  (swap! !x inc)  @it := :init                           ; first recovery starts\n  (swap! !x inc)  @it := :init, % := :unmounted          ; second starts, first unmounts\n  (it)            @it :throws Cancelled, % := :unmounted, % := :terminated)\n(tests \"an immediately ready input works\"\n  (def it ((yield (fn [x] (when (pos? x) (m/cp :recover))) (m/seed [0 1 2]))  #(do) #(tap :terminated)))\n  ;; 0 and 1 are not seen because of the consecutive transfer\n  @it := :recover, (it), % := :terminated)\n(tests \"an immediately ready recovery works\"\n  (def it ((yield (fn [_] (m/seed [0 1 2])) (m/cp :hi)) #(do) #(tap :terminated)))\n  ;; 0 and 1 are not seen because of the consecutive transfer\n  @it := 2, (it), % := :terminated)\n(tests \"input throws\"\n  (def !x (atom 0))\n  (def it ((yield (constantly nil) (m/latest #(if (pos? %) (throw (ex-info \"pos\" {})) %) (m/watch !x)))\n           #(tap :notified) #(tap :terminated)))\n                 % := :notified, @it := 0\n  (swap! !x inc) % := :notified, @it :throws ExceptionInfo, % := :terminated)\n(tests \"recovery throws\"\n  (def !x (atom 0))\n  (def it ((yield (fn [x] (when (pos? x) (m/cp (throw (ex-info \"boom\" {}))))) (m/watch !x))\n           #(tap :notified) #(tap :terminated)))\n  #_start         % := :notified, @it := 0\n  (swap! !x inc), % := :notified, @it :throws ExceptionInfo, % := :terminated)\n(tests \"recovery unmounts when we switch back to input\"\n  (def !x (atom 0))\n  (let [->recover (m/observe (fn [!] (! :init) #(tap :unmounted)))]\n    (def it ((yield (fn [x] (when (odd? x) ->recover)) (m/watch !x))  #(do) #(tap :terminated))))\n  #_start         @it := 0\n  (swap! !x inc)  @it := :init              ; recovery starts\n  (swap! !x inc)  @it := 2, % := :unmounted ; back to input, recovery stops\n  (it)            @it :throws Cancelled, % := :terminated)\n(tests \"work skipping is invalidated after successful input\"\n  (def !x (atom 0))\n  (def it ((yield (fn [x] (when (odd? x) (tap :recover) (m/cp :recover))) (m/watch !x))  #(do) #(tap :terminated)))\n  #_start         @it := 0\n  (swap! !x inc)  @it := :recover, % := :recover\n  (swap! !x inc)  @it := 2\n  \"same input but good input in between, so won't work skip\"\n  (swap! !x dec)  @it := :recover, % := :recover\n  (it)            @it :throws Cancelled, % := :terminated)\n(tests \"initial nil isn't work skipped\"\n  (def it ((yield (fn [_] (tap :recover) nil) (m/cp nil))  #(do) #(do)))\n  @it := nil, % := :recover)\n(tests \"cache updates on recover values\"\n  (def !in (atom 0))\n  (def !x (atom 0))\n  (def it ((yield (fn [_] (m/watch !x)) (m/watch !in)) #(do) #(do)))\n  #_start              @it := 0\n  (swap! !x inc)       @it := 1\n  (swap! !in identity) @it := 1)\n(tests \"yield stays alive as long as the recover is alive\"\n  (def !x (atom 0))\n  (def it ((yield (fn [_] (m/watch !x)) (m/cp)) #(tap :notified) #(tap :terminated)))\n  #_start        % := :notified, @it := 0\n  (swap! !x inc) % := :notified, @it := 1)\n(tests \"if same input arrives and recover notified recover is re-transferred\"\n  (def !x (atom 0))\n  (def !err (atom 100))\n  (def it ((yield (fn [_] (m/watch !err)) (m/watch !x)) #(tap :notified) #(tap :terminated)))\n  #_start                              % := :notified, @it := 100\n  (swap! !err inc) (swap! !x identity) % := :notified, @it := 101\n  (swap! !err inc)                     % := :notified, @it := 102)\n"]}