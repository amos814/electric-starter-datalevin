{"version":3,"sources":["contrib/data.cljc"],"mappings":"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","names":["js/Error","contrib.data/qualify","ns","?kw","cljs.core/Keyword","cljs.core/qualified-keyword?","cljs.core.keyword","cljs.core/name","contrib.data/unqualify","?qualified-kw","contrib.data/-omit-keys-ns","?m","cljs.core/reduce-kv","m","k","v","cljs.core._EQ_","cljs.core/namespace","cljs.core.assoc","contrib.data/has-ns?","named","cljs.core/simple-ident?","contrib.data/select-ns","map","cljs.core.into","cljs.core/empty","cljs.core.filter","p__39257","vec__39258","cljs.core.nth","_v","contrib.data/-auto-props","props","defaults-qualified","cljs.core/Symbol","cljs.core.merge","cljs.core/update-keys","cljs.core.partial","var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","contrib.data/xorxs","p__39279","vec__39281","seq39268","G__39269","cljs.core/first","cljs.core/next","self__5754__auto__","xorxs","zero","cljs.core/vector?","cljs.core/set?","cljs.core/seq?","cljs.core.conj","or__5045__auto__","contrib.data/index-by","kf","xs","cljs.core.map_indexed","i","x","contrib.data/index","cljs.core/sequential?","contrib.data/group-by-pred","f?","map__39301","cljs.core/--destructure-map","cljs.core.get","a","b","cljs.core/group-by","contrib.data/update-existing","seq39302","G__39303","G__39304","G__39305","f","args","cljs.core.apply","cljs.core/update","contrib.data/round-floor","n","base","cljs.math/floor","G__39319","contrib.data/pad","coll","cljs.core.concat","cljs.core.repeat","cljs.core.take","contrib.data.pad","contrib.data/padl","cljs.core/count","contrib.data/assoc-vec","cljs.core/vec","contrib.data/padl-str","s","cljs.core/str","contrib.data/with-pad","reducer","cols","cljs.core/max","cljs.core.map","p1__39340#","contrib.data/map-pad","cljs.core/map","contrib.data/str-last-n","cljs.core/reverse","contrib.data/nil-or-empty?","cljs.core/seqable?","cljs.core/empty?","contrib.data/-tree-list","depth","children-fn","keep?","input","cljs.core.eduction","cljs.core.mapcat","clojure.datafy/datafy","temp__5802__auto__","children","temp__5804__auto__","rows","cljs.core/seq","G__39386","G__39387","G__39388","G__39389","G__39390","G__39391","G__39395","contrib.data/treelister","contrib.data.treelister","_"],"sourcesContent":["(ns contrib.data\n  (:require clojure.math\n            [clojure.datafy :refer [datafy]] ; todo remove\n            [hyperfiddle.rcf :refer [tests]])\n  #?(:cljs (:require-macros [contrib.data :refer [auto-props]])))\n\n(defn qualify\n  \"Qualify a keyword with a namespace. If already qualified, leave kw untouched. Nil-safe.\n  (qualify :db :isComponent) -> :db/isComponent\"\n  [ns ?kw]\n  {:pre [(some? ns) #_(not (namespace ns)) (keyword? ?kw)]}\n  (when ?kw\n    (if (qualified-keyword? ?kw)\n      ?kw (keyword (name ns) (name ?kw)))))\n\n(tests\n  ;(keyword (name (namespace ::ns)) (name :limit))\n  (qualify (namespace ::x) :limit) := ::limit\n  ;(qualify (namespace ::x) \"limit\") thrown? AssertionError\n  \"leave qualified kws untouched\"\n  (qualify (namespace ::x) :user/foo) := :user/foo)\n\n(defn unqualify\n  \"Strip namespace from keyword, discarding it and return unqualified keyword. Nil-safe.\n  (unqualify :db.type/ref) -> :ref\"\n  [?qualified-kw]\n  (assert (or (nil? ?qualified-kw)\n              (qualified-keyword? ?qualified-kw)) (str \" can't unqualify: \" ?qualified-kw))\n  (if ?qualified-kw\n    (keyword (name ?qualified-kw))))\n\n(tests\n  (unqualify ::x) := :x\n  (unqualify :db.type/ref) := :ref\n  (unqualify nil) := nil\n  (unqualify \"\") :throws #?(:clj AssertionError :cljs js/Error))\n\n(defn -omit-keys-ns [ns ?m]\n  {:pre [(some? ns)]}\n  (when ?m\n    (reduce-kv (fn [m k v] (if (= (name ns) (namespace k))\n                             m (assoc m k v))) {} ?m)))\n\n(defmacro omit-keys-ns\n  ([?m] `(-omit-keys-ns ~(str *ns*) ~?m))\n  ([ns- ?m] `(-omit-keys-ns ~ns- ~?m)))\n\n(tests\n  (omit-keys-ns :c {::a 1 :b 2 :c/c 3}) := {::a 1 :b 2}\n  (omit-keys-ns :c {::a 1 :b 2 :c/c 3}) := {::a 1 :b 2}\n  (omit-keys-ns :c nil) := nil\n  (omit-keys-ns nil {::a 1 :b 2 :c/c 3}) :throws #?(:clj AssertionError :cljs js/Error)\n  (omit-keys-ns nil nil) :throws #?(:clj AssertionError :cljs js/Error)\n  nil)\n\n(defn has-ns?\n  \"State if a `named` value (keyword or symbol) has such namespace `ns`.\n  `ns` can be be a string, or a non-namespaced keyword or symbol.\"\n  [ns named]\n  {:pre [(or (string? ns) (simple-ident? ns))]}\n  (= (name ns) (namespace named)))\n\n(defn select-ns\n  \"Like `select-keys` but select all namespaced keys by ns.\"\n  [ns map]\n  (into (empty map) (filter (fn [[k _v]] (has-ns? ns k))) map))\n\n(defn -auto-props \"qualify any unqualified keys to the current ns and then add qualified defaults\"\n  [ns props defaults-qualified]\n  {:pre [(some? ns) (or (string? ns) (symbol? ns))]}\n  (merge defaults-qualified (update-keys props (partial qualify ns))))\n\n(defmacro auto-props\n  ([ns props defaults-qualified] `(-auto-props ~ns ~props ~defaults-qualified))\n  ([props defaults-qualified] `(-auto-props ~(str *ns*) ~props ~defaults-qualified))\n  ([props] `(-auto-props ~(str *ns*) ~props {})))\n\n(tests\n  (auto-props \"user\" {:a 1} {:dom/class \"a\"}) := {:user/a 1 :dom/class \"a\"}\n  (auto-props 'user {:a 1} {:dom/class \"a\"}) := {:user/a 1 :dom/class \"a\"}\n  (auto-props *ns* {:a 1} {:dom/class \"a\"}) :throws #?(:clj AssertionError :cljs js/Error)\n  (auto-props {:a 1} {:dom/class \"a\"}) := {:contrib.data/a 1 :dom/class \"a\"}\n  (auto-props {:a 1}) := {:contrib.data/a 1})\n\n(defn xorxs\n  \"an argument parser that accepts both scalars and collections, lifting scalars into a collection\"\n  [xorxs & [zero]]\n  (cond (vector? xorxs) xorxs\n        (set? xorxs) xorxs\n        (seq? xorxs) xorxs\n        (nil? xorxs) zero\n        :else-single-value-or-map (conj (or zero []) xorxs)))\n\n(tests\n  (xorxs :a)     := [:a]\n  (xorxs [:a])   := [:a]\n  (xorxs #{:a})  := #{:a}\n  (xorxs :a #{}) := #{:a}\n  (xorxs :a [])  := [:a]\n  (xorxs nil #{}) := #{}\n  (xorxs nil) := nil)\n\n(defn index-by [kf xs]\n  {:pre [kf]}\n  (into {} (map-indexed (fn [i x]\n                          [(kf x i) ; fallback to index when key is not present\n                           #_(if-not kf (kf x i) i) ; alternative design is to define nil kf as fallback\n                           x])) xs))\n\n(tests\n  (def xs [{:db/ident :foo :a 1}\n           {:db/ident :bar :b 2}])\n\n  (index-by :db/ident xs)\n  := {:foo {:db/ident :foo, :a 1},\n         :bar {:db/ident :bar, :b 2}}\n\n  (index-by ::missing xs) ; should this throw?\n  := {0 {:db/ident :foo, :a 1},\n      1 {:db/ident :bar, :b 2}}\n\n  ;\"nil kf uses default value (which is likely unintended, should it throw?)\"\n  ;(index-by nil xs)\n  ;:= {0 {:db/ident :foo, :a 1},\n  ;    1 {:db/ident :bar, :b 2}}\n\n  (index-by :a nil) := {}\n  ;(index-by nil nil) := {} ; kf never used -- alternative design\n  (index-by nil nil) :throws #?(:clj AssertionError :cljs js/Error)\n\n  (index-by :a [{}]) := {0 {}}\n  (index-by :a [{:a 1}]) := {1 {:a 1}}\n  (index-by :b [{:a 1}]) := {0 {:a 1}} ; missing key, fallback to index\n\n  \"indexing map entries (which is weird, should this throw?)\"\n  (index-by :a {:a 1}) := {0 [:a 1]} ; index the map entry, not the map, :a is missing so fallback\n  (index-by :b {:a 1}) := {0 [:a 1]}\n\n  \"collisions are possible\"\n  (index-by :db/id [{:db/id 1} {:db/id 2} {:db/id 1}]) ; should this detect collision and throw?\n  := {1 #:db{:id 1}, 2 #:db{:id 2}}\n\n  \"kf fallback arity\"\n  (index-by (fn [x i] (str i)) xs)\n  := {\"0\" {:db/ident :foo, :a 1},\n      \"1\" {:db/ident :bar, :b 2}}\n\n  \"index by first element\"\n  ;(index-by first [[:a 1] [:b 2]]) -- ArityException: kf must accept fallback. Is this a mistake?\n  (index-by (fn [a b] (first a)) [[:a 1] [:b 2]]) := {:a [:a 1], :b [:b 2]}\n  (index-by #(do %2 (first %1)) [[:a 1] [:b 2]]) := {:a [:a 1], :b [:b 2]})\n\n(defn index\n  \"index a sequential collection into an associative collection with explicit keys. this may not be\n  useful, as vectors are already associative\"\n  [xs]\n  (assert (sequential? xs)) ; maps are not indexable\n  (index-by (fn [x i] i) xs))\n\n(tests\n  (def xs [{:db/ident :foo :a 1}\n           {:db/ident :bar :b 2}])\n  (index xs)\n  := {0 {:db/ident :foo, :a 1},\n      1 {:db/ident :bar, :b 2}})\n\n(defn group-by-pred [f? xs] ; todo rename\n  (let [{a true b false} (group-by f? xs)]\n    [a b]))\n\n(tests\n  (group-by-pred map? [:user/email\n                       {:user/gender [:db/ident]}\n                       {:user/shirt-size [:db/ident]}\n                       :db/id])\n  := [[#:user{:gender [:db/ident]}\n       #:user{:shirt-size [:db/ident]}]\n      [:user/email\n       :db/id]])\n\n(defn update-existing [m k f & args]\n  (if (get m k)\n    (apply update m k f args)\n    m))\n\n(tests\n  (update-existing {:a 1} :a + 10) := {:a 11}\n  (update-existing {:a 1} :b + 10) := {:a 1})\n\n;(defn positional\n;  \"Transform an array-like map {0 :foo, 1 :bar, ...} with contiguous array keys (0, 1, ...) into\n;   list [:foo :bar]\"\n;  [amap]\n;  (->> (range (inc (count amap)))\n;       (reduce (fn [acc idx]\n;                 (if (contains? amap idx)\n;                   (conj acc (get amap idx))\n;                   (reduced acc)))\n;               [])\n;       (seq)))\n;\n;(tests (positional {0 :foo 1 :bar}) := [:foo :bar])\n\n(defn round-floor [n base] (* base (clojure.math/floor (/ n base))))\n\n(comment\n  \"base 10\"\n  (round-floor 89 10) := 80.0\n  (round-floor 90 10) := 90.0\n  (round-floor 91 10) := 90.0\n  (round-floor 99 10) := 90.0\n  (round-floor 100 10) := 100.0\n  \"base 8\"\n  (round-floor 7 8) := 0.0\n  (round-floor 8 8) := 8.0\n  (round-floor 9 8) := 8.0\n  (round-floor 15 8) := 8.0\n  (round-floor 16 8) := 16.0\n\n  (round-floor 1234567 1000) := 1234000.0)\n\n(defn pad\n  ([zero coll] (concat coll (repeat zero)))\n  ([n zero coll] (take n (pad zero coll))))\n\n(defn padl [n zero coll] (concat (repeat (- n (count coll)) zero) coll))\n\n(tests\n  (pad 8 0 (range 3)) := [0 1 2 0 0 0 0 0]\n  (padl 8 0 (range 3)) := [0 0 0 0 0 0 1 2]\n\n  \"strings leak platform internals, use padl-str\"\n  (pad 8 \"0\" \"xx\") := #?(:clj [\\x \\x \"0\" \"0\" \"0\" \"0\" \"0\" \"0\"]\n                         :cljs [\"x\" \"x\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\"])\n\n  (padl 8 \"0\" \"xx\") := #?(:clj [\"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \\x \\x]\n                          :cljs [\"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"x\" \"x\"]))\n\n(defn assoc-vec [xs k v]\n  (if (>= k (count xs))\n    (assoc (vec (pad k nil xs)) k v)\n    (assoc xs k v)))\n\n(tests\n  (assoc-vec [] 0 :a) := [:a]\n  (assoc-vec [] 1 :b) := [nil :b]\n  (assoc-vec [] 4 :e) := [nil nil nil nil :e]\n  (assoc-vec nil 4 :e) := [nil nil nil nil :e]\n  (assoc-vec [:a :b :c] 1 :B) := [:a :B :c]\n  (assoc-vec [:a :b :c] 4 :E) := [:a :b :c nil :E])\n\n(defn padl-str [n zero s] (apply str (padl n zero s)))\n\n(tests\n  (padl-str 8 \"0\" \"xx\") := \"000000xx\"\n  (padl-str 4 \"0\" (str 11)) := \"0011\")\n\n(defn with-pad [reducer zero]\n  (fn [f & cols]\n    (let [n (apply max (map count cols))\n          cols (map #(pad n zero %) cols)]\n      (apply reducer f cols))))\n\n(def map-pad (partial with-pad map))\n\n(tests\n  (map + [1 1 1] [1 1 1 1]) := '(2 2 2)\n  ((map-pad 0) + [1 1 1] [1 1 1 1]) := '(2 2 2 1))\n\n(defn str-last-n [n s]\n  #?(:clj (.substring s (max 0 (- (.length s) n)))\n     :cljs (apply str (reverse (take n (reverse s))))))\n\n(tests\n  (str-last-n 4 \"0123456789\") := \"6789\")\n\n; org.apache.commons.lang3.StringUtils.containsIgnoreCase()\n;(defn str-contains-ignore-case [])\n\n;(defn clamp [n min max] (Math/min (Math/max n min) max))\n;\n;(tests\n;  (clamp 51 10 50) := 50\n;  (clamp 50 10 50) := 50\n;  (clamp 49 10 50) := 49\n;  (clamp 11 10 50) := 11\n;  (clamp 10 10 50) := 10\n;  (clamp 9  10 50) := 10)\n\n#?(:clj\n   (defmacro orp\n     \"`clojure.core/or` evaluates arguments one by one, returning the first truthy\n  one and so leaving the remaining ones unevaluated. `orp` does the same but\n  with a custom predicate.\"\n     ([pred] nil)\n     ([pred x]\n      `(let [or# ~x]\n         (when (~pred or#) or#)))\n     ([pred x & next]\n      `(let [or# ~x]\n         (if (~pred or#) or# (orp ~pred ~@next))))))\n\n(tests\n  (orp some? nil false 1) := false\n  (orp even? 1 3 5 6 7) := 6)\n\n(defn nil-or-empty? [x]\n  (if (seqable? x)\n    (empty? x)\n    (nil? x)))\n\n(defn- -tree-list [depth xs children-fn keep? input]\n  (eduction (mapcat (fn [x]\n                      (let [x (datafy x)]\n                        (if-let [children (children-fn x)]\n                          (when-let [rows (seq (-tree-list (inc depth) children children-fn keep? input))]\n                            (into [[depth x]] rows))\n                          (cond-> [] (keep? x input) (conj [depth x]))))))\n    (datafy xs)))\n\n(defn treelister\n  ([xs] (treelister xs (fn [_]) (fn [_ _] true)))\n  ([xs children-fn keep?] (fn [input] (-tree-list 0 xs children-fn keep? input))))\n\n(tests\n  (vec ((treelister [1 2 [3 4] [5 [6 [7]]]] #(when (vector? %) %) (fn [v _] (odd? v))) nil))\n  := [[0 1] [0 [3 4]] [1 3] [0 [5 [6 [7]]]] [1 5] [1 [6 [7]]] [2 [7]] [3 7]]\n\n  ((treelister [{:dir \"x\" :children [{:file \"a\"} {:file \"b\"}]}] :children (fn [v needle] (-> v :file #{needle})) ) \"a\")\n  (count (vec *1)) := 2\n\n  \"directory is omitted if there are no children matching keep?\"\n  ((treelister [{:dir \"x\" :children [{:file \"a\"} {:file \"b\"}]}] :children (fn [v needle] (-> v :file #{needle}))) \"nope\")\n  (count (vec *1)) := 0)"]}