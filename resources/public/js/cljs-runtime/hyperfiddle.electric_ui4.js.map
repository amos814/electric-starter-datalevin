{"version":3,"sources":["hyperfiddle/electric_ui4.cljc"],"mappings":"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","names":["hyperfiddle.electric-ui4/value","e","hyperfiddle.electric-ui4/checked","hyperfiddle.electric-ui4/parse-edn","s","e47966","G__47967","contrib.str/blank->nil","clojure.edn.read_string","_","hyperfiddle.electric-ui4/keep-if","pred","v","hyperfiddle.electric-ui4/parse-keyword","cljs.core/keyword?","hyperfiddle.electric-ui4/parse-symbol","cljs.core/symbol?","hyperfiddle.electric-ui4/uuid-pattern","hyperfiddle.electric-ui4/parse-date","e47970","js/Date","hyperfiddle.electric-ui4/parse-datetime-local","e47971","hyperfiddle.electric-ui4/first-option","elem","hyperfiddle.electric-ui4/last-option","hyperfiddle.electric-ui4/next-option","or__5045__auto__","hyperfiddle.electric-ui4/prev-option","hyperfiddle.electric-ui4/own","event","hyperfiddle.electric-ui4/?pass-on-to-first","selected","cljs.core._EQ_","fst","hyperfiddle.electric-ui4/select-if-first","hyperfiddle.electric-ui4/track-id","node","id","hyperfiddle.electric-ui4/get-id","hyperfiddle.electric-ui4/focus","js/window","js/FocusEvent","hyperfiddle.electric-ui4/sample-scroll-state!","scrollable","hyperfiddle.electric-ui4/scroll-state>","missionary.core/observe","!","sample","G__48024","hyperfiddle.electric-ui4/!scrollStateDebug","cljs.core.atom","hyperfiddle.electric-ui4/scroll-state<","hyperfiddle.electric/throttle","missionary.core.reductions","missionary.core/relieve","missionary.core.latest","p__48025","vec__48026","cljs.core.nth","scrollTop","scrollHeight","clientHeight","cljs.core/reset!"],"sourcesContent":["(ns hyperfiddle.electric-ui4\n  #?(:cljs (:require-macros hyperfiddle.electric-ui4))\n  (:refer-clojure :exclude [long double keyword symbol uuid range])\n  (:require\n    clojure.edn\n    [contrib.str]\n    [hyperfiddle.electric :as e]\n    [hyperfiddle.electric-dom2 :as dom]\n    [missionary.core :as m]))\n\n(defmacro handle [getter V!]\n  `(e/fn [e#]\n     (dom/props {:style {:background-color \"yellow\"}})\n     (when-some [v# (~getter e#)] (new ~V! v#))))\n\n(defmacro do1 [x & body] `(let [ret# ~x] ~@body ret#))\n\n#?(:cljs (defn value [^js e] (.-target.value e)))\n#?(:cljs (defn checked [^js e] (.-target.checked e)))\n\n(defmacro input [v V! & body]           ; todo nominal args\n  `(dom/input\n     (dom/bind-value ~v)\n     (do1 (dom/on \"input\" (handle value ~V!)) ~@body)))\n\n(defmacro textarea [v V! & body]\n  `(dom/textarea\n     (dom/bind-value ~v)\n     (do1 (dom/on \"input\" (handle value ~V!)) ~@body)))\n\n(defn parse-edn [s] (try (some-> s contrib.str/blank->nil clojure.edn/read-string) (catch #?(:clj Throwable :cljs :default) _)))\n(defn keep-if [pred v] (when (pred v) v))\n(defn parse-keyword [s] (keep-if keyword? (parse-edn s)))\n(defn parse-symbol [s] (keep-if symbol? (parse-edn s)))\n\n(defmacro edn [v V! & body]\n  `(dom/textarea\n     (dom/bind-value (contrib.str/pprint-str ~v))\n     (do1 (dom/on \"input\" (handle (comp parse-edn value) ~V!)) ~@body)))\n\n(defmacro checkbox [v V! & body]\n  `(dom/input (dom/props {:type \"checkbox\"})\n     (dom/bind-value ~v (fn [node# v#] (set! (.-checked node#) v#)))\n     (do1 (dom/on \"change\" (handle checked ~V!)) ~@body)))\n\n(defmacro long [v V! & body]\n  `(dom/input (dom/props {:type \"number\"})\n     (dom/bind-value ~v)\n     (do1 (dom/on \"input\" (handle (comp parse-long value) ~V!)) ~@body)))\n\n(defmacro range [v V! & body]\n  `(dom/input (dom/props {:type \"range\"})\n     (dom/bind-value ~v)\n     (do1 (dom/on \"input\" (handle (comp parse-long value) ~V!)) ~@body)))\n\n(defmacro double [v V! & body]\n  `(dom/input (dom/props {:type \"number\"})\n     (dom/bind-value ~v)\n     (do1 (dom/on \"input\" (handle (comp parse-double value) ~V!)) ~@body)))\n\n(def uuid-pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n(defmacro uuid [v V! & body]\n  `(dom/input (dom/props {:type \"text\" :pattern uuid-pattern})\n     (dom/bind-value ~v)\n     (do1 (dom/on \"input\" (handle (comp parse-uuid value) ~V!)) ~@body)))\n\n(defmacro keyword [v V! & body]\n  `(dom/input\n     (dom/bind-value ~v)\n     (do1 (dom/on \"input\" (handle (comp parse-keyword value) ~V!)) ~@body)))\n\n(defmacro symbol [v V! & body]\n  `(dom/input\n     (dom/bind-value ~v)\n     (do1 (dom/on \"input\" (handle (comp parse-symbol value) ~V!)) ~@body)))\n\n(defn parse-date [s]\n  (try #?(:clj (java.time.LocalDate/parse s) :cljs (js/Date. s))\n       (catch #?(:clj Throwable :cljs :default) _)))\n\n(defn parse-datetime-local [s]\n  (try #?(:clj (java.time.LocalDateTime/parse s) :cljs (js/Date. s))\n       (catch #?(:clj Throwable :cljs :default) _)))\n\n(defmacro date [v V! & body]\n  `(dom/input (dom/props {:type \"date\"})\n     (dom/bind-value ~v)\n     (do1 (dom/on \"input\" (handle (comp parse-date value) ~V!)) ~@body)))\n\n(defmacro datetime-local [v V! & body]\n  `(dom/input (dom/props {:type \"datetime-local\"})\n     (dom/bind-value ~v)\n     (do1 (dom/on \"input\" (handle (comp parse-datetime-local value) ~V!)) ~@body)))\n\n(defmacro button [V! & body]\n  `(dom/button\n     (do1 (dom/on \"click\" (e/fn [e#]\n                            (dom/props {:disabled true, :aria-busy true})\n                            (new ~V!))) ; do we need to pass the event?\n          ~@body)))\n\n\n\n;;; TYPEAHEAD\n\n#?(:cljs (defn first-option [elem] (-> elem .-parentElement .-firstElementChild)))\n#?(:cljs (defn last-option  [elem] (-> elem .-parentElement .-lastElementChild)))\n#?(:cljs (defn next-option  [elem] (-> elem .-nextElementSibling (or (first-option elem)))))\n#?(:cljs (defn prev-option  [elem] (-> elem .-previousElementSibling (or (last-option elem)))))\n\n#?(:cljs (defn own [event] (.stopPropagation event) (.preventDefault event)))\n\n(defmacro ?mark-selected [selected] `(when (= dom/node ~selected) (dom/props {:class [\"hyperfiddle-selected\"]})))\n\n(defmacro return-on-click [return V! id]\n  `(dom/on \"click\" (e/fn [e#] (own e#)\n                     (dom/props {:style {:background-color \"yellow\"}})\n                     (~return (e/server (new ~V! ~id))))))\n\n#?(:cljs (defn ?pass-on-to-first [selected elem]\n           (if (= selected elem)\n             (let [fst (first-option elem)]\n               (if (= fst elem)\n                 (-> elem .-parentElement .-nextElementSibling)\n                 fst))\n             selected)))\n\n#?(:cljs (defn select-if-first [selected elem] (if (= elem (first-option elem)) elem selected)))\n\n#?(:cljs (defn track-id [node id] (set! (.-hyperfiddle-id ^js node) id)))\n#?(:cljs (defn get-id [node] (.-hyperfiddle-id ^js node)))\n\n(defmacro handle-meta-keys [e input-node return !selected V!]\n  `(case (.-key ~e)\n     \"Escape\"    (do (own ~e) (.blur ~input-node) (~return nil))\n     \"ArrowDown\" (do (own ~e) (swap! ~!selected next-option))\n     \"ArrowUp\"   (do (own ~e) (swap! ~!selected prev-option))\n     \"Enter\"     (do (own ~e) (when-some [elem# @~!selected]\n                                (let [id# (get-id elem#)]\n                                  (.blur ~input-node)\n                                  (~return (e/server (new ~V! id#))))))\n     \"Tab\"       (if-some [elem# @~!selected]\n                   (let [id# (get-id elem#)] (~return (e/server (new ~V! id#))))\n                   (~return nil))\n     #_else      ::unhandled))\n\n(defmacro for-truncated [[sym opts] limit & body]\n  `(let [limit# ~limit, opts# ~opts, truncated# (take limit# opts#), more?# (seq (drop limit# opts#))]\n     (e/for [~sym truncated#] ~@body)\n     (when more?#\n       (e/client\n         (dom/div (dom/text \"refine your query...\")\n           (dom/props {:disabled true, :style {:background-color \"whitesmoke\" :font-size \"0.8rem\" :font-style \"italic\"}}))))))\n\n;; TODO\n;; - what if the change callback throws\n(defmacro typeahead [v V! Options OptionLabel & body] ; server biased\n  `(let [v# ~v, V!# ~V!, Options# ~Options, OptionLabel# ~OptionLabel]\n     (e/client\n       (dom/div (dom/props {:class \"hyperfiddle-typeahead\"})\n         (let [container-node# dom/node]\n           (do1\n             (dom/input\n               (let [input-node# dom/node\n                     return# (dom/on \"focus\"\n                               (e/fn [_#] ; FIXME Exceptions seems to be swallowed here\n                                 (set! (.-value dom/node) \"\")\n                                 (let [return# (missionary.core/dfv)\n                                       search# (or (dom/on! \"input\" value) \"\")]\n                                   (binding [dom/node container-node#]\n                                     (let [!selected# (atom nil), selected# (e/watch !selected#)]\n                                       (dom/div (dom/props {:class \"hyperfiddle-modal-backdrop\"})\n                                         (dom/on \"click\" (e/fn [e#] (return# nil))))\n                                       (dom/on \"keydown\" (e/fn [e#] (handle-meta-keys e# input-node# return# !selected# V!#)))\n                                       (dom/ul\n                                         (e/server\n                                           (for-truncated [id# (new Options# search#)] 20\n                                             (e/client\n                                               (dom/li (dom/text (e/server (new OptionLabel# id#)))\n                                                 (swap! !selected# select-if-first dom/node)\n                                                 (e/on-unmount #(swap! !selected# ?pass-on-to-first dom/node))\n                                                 (track-id dom/node id#)\n                                                 (?mark-selected selected#)\n                                                 (dom/on \"mouseover\" (e/fn [e#] (reset! !selected# dom/node)))\n                                                 (return-on-click return# V!# id#))))))))\n                                   (new (e/task->cp return#)))))]\n                 (case return#\n                   (let [txt# (e/server (new OptionLabel# v#))]\n                     (case return# (set! (.-value input-node#) txt#))))\n                 return#))\n             ~@body))))))\n\n(defmacro select [v V! Options OptionLabel & body] ; server biased!\n  `(let [v# ~v, V!# ~V!, Options# ~Options, OptionLabel# ~OptionLabel]\n     (e/client\n       (dom/div (dom/props {:class \"hyperfiddle-select\"})\n         (let [container-node# dom/node]\n           (do1\n             (dom/input (dom/props {:style {:caret-color \"transparent\"}}) ; hides cursor\n               (let [input-node# dom/node\n                     return#\n                     (dom/on \"focus\"\n                       (e/fn [_#]\n                         (let [return#    (missionary.core/dfv)\n                               !selected# (atom nil), selected# (e/watch !selected#)]\n                           (binding [dom/node container-node#]\n                             (dom/div (dom/props {:class \"hyperfiddle-modal-backdrop\"})\n                               (dom/on \"click\" (e/fn [e#] (return# nil))))\n                             (dom/on \"keydown\" (e/fn [e#] (case (handle-meta-keys e# input-node# return# !selected# V!#)\n                                                            ::unhandled (own e#)\n                                                            #_else      nil)))\n                             (dom/ul\n                               (e/server\n                                 (e/for [id# (new Options#)]\n                                   (e/client\n                                     (let [txt# (e/server (new OptionLabel# id#))]\n                                       (dom/li (dom/text txt#)\n                                         (when (= txt# (.-value input-node#)) (reset! !selected# dom/node))\n                                         (track-id dom/node id#)\n                                         (?mark-selected selected#)\n                                         (dom/on \"mouseover\" (e/fn [e#] (reset! !selected# dom/node)))\n                                         (return-on-click return# V!# id#))))))))\n                           (new (e/task->cp return#)))))]\n                 (case return#\n                   (let [txt# (e/server (new OptionLabel# v#))]\n                     (case return# (set! (.-value input-node#) txt#))))\n                 return#))\n             ~@body))))))\n\n#?(:cljs\n   (defn focus [elem]\n     (.focus elem #js {\"focusVisible\" true})\n     (.setTimeout js/window #(do\n                               (.dispatchEvent elem (js/FocusEvent. \"focus\"))\n                               (.dispatchEvent elem (js/FocusEvent. \"focusin\" #js {:bubbles true}))))))\n\n(defmacro tag-picker [v V! unV! Options OptionLabel & body]\n  `(let [v# ~v, V!# ~V!, unV!# ~unV!, Options# ~Options, OptionLabel# ~OptionLabel]\n     (e/client\n       (dom/div (dom/props {:class \"hyperfiddle-tag-picker\"})\n         (let [container-node# dom/node]\n           (do1\n             (dom/ul (dom/props {:class \"hyperfiddle-tag-picker-items\"})\n               (e/server\n                 (e/for [id# v#]\n                   (let [txt# (new OptionLabel# id#)]\n                     (e/client (dom/li (dom/text txt#)\n                                 (dom/span (dom/text \"\u00d7\")\n                                   (dom/on \"click\" (e/fn [e#] (own e#) (e/server (new unV!# id#)))))))))))\n             (dom/div (dom/props {:class \"hyperfiddle-tag-picker-input-container\"})\n               (let [input-container-node# dom/node]\n                 (dom/input\n                   (let [input-node# dom/node]\n                     (binding [dom/node container-node#] (dom/on \"click\" (e/fn [e#] (own e#) (focus input-node#))))\n                     (if (e/server (nil? V!#))\n                       (dom/props {:disabled true})\n                       (dom/on \"focus\"\n                         (e/fn [_#]\n                           (let [return# (missionary.core/dfv)\n                                 search# (or (dom/on! \"input\" value) \"\")]\n                             (binding [dom/node input-container-node#]\n                               (let [!selected# (atom nil), selected# (e/watch !selected#)]\n                                 (dom/div (dom/props {:class \"hyperfiddle-modal-backdrop\"})\n                                   (dom/on \"click\" (e/fn [e#] (own e#) (return# nil))))\n                                 (dom/on \"keydown\" (e/fn [e#] (handle-meta-keys e# input-node# return# !selected# V!#)))\n                                 (dom/ul\n                                   (e/server\n                                     (for-truncated [id# (new Options# search#)] 20\n                                       (e/client\n                                         (dom/li (dom/text (e/server (new OptionLabel# id#)))\n                                           (swap! !selected# select-if-first dom/node)\n                                           (e/on-unmount #(swap! !selected# ?pass-on-to-first dom/node))\n                                           (track-id dom/node id#)\n                                           (?mark-selected selected#)\n                                           (dom/on \"mouseover\" (e/fn [e#] (reset! !selected# dom/node)))\n                                           (return-on-click return# V!# id#))))))))\n                             (let [ret# (new (e/task->cp return#))]\n                               (case ret# (set! (.-value input-node#) \"\"))\n                               ret#)))))))))\n             ~@body))))))\n\n#?(:cljs (defn sample-scroll-state! [scrollable]\n           [(.. scrollable -scrollTop) ; optimization - detect changes (pointless)\n            (.. scrollable -scrollHeight) ; snapshot height to detect layout shifts in flipped mode\n            (.. scrollable -clientHeight)])) ; measured viewport height (scrollbar length)\n\n#?(:cljs (defn scroll-state> [scrollable]\n           (m/observe\n             (fn [!]\n               (let [sample (fn [] (! (sample-scroll-state! scrollable)))]\n                 (.addEventListener scrollable \"scroll\" sample #js {\"passive\" true})\n                 #(.removeEventListener scrollable \"scroll\" sample))))))\n\n#?(:cljs (def !scrollStateDebug (atom nil)))\n\n#?(:cljs (defn scroll-state< [scrollable]\n           (->> (scroll-state> scrollable)\n                (e/throttle 16) ; RAF interval\n                (m/reductions {} [0 0 0])\n                (m/relieve {})\n                (m/latest (fn [[scrollTop scrollHeight clientHeight :as s]]\n                            (reset! !scrollStateDebug {::scrollTop scrollTop\n                                                       ::scrollHeight scrollHeight\n                                                       ::clientHeight clientHeight})\n                            s)))))\n"]}