{"version":3,"sources":["contrib/cljs_target.cljc"],"mappings":";;;;AAQS,oCAAA,pCAAMA;AAAN,AAAiB,iFAAA,1EAACC,6CAAEC;;AACpB,qCAAA,rCAAMC;AAAN,AAAkB,iFAAA,1EAACF,6CAAEC","names":["contrib.cljs-target/nodejs?","cljs.core._EQ_","cljs.core/*target*","contrib.cljs-target/browser?"],"sourcesContent":["(ns contrib.cljs-target\n  \"Do not guard this require to cljs only, it contains clj macros. It is safe to \nrequire from clj and cljs due to careful consideration below.\"\n  #?(:cljs (:require-macros [contrib.cljs-target]))\n  ;(:require cljs.env) -- clojurescript must be on classpath during server macroexpansion (AOT or runtime depending on config)\n  #?(:cljs (:require [goog.object :as object])))\n\n; preferred runtime check for target through public API https://cljs.github.io/api/cljs.core/STARtargetSTAR\n#?(:cljs (defn nodejs? [] (= cljs.core/*target* \"nodejs\")))\n#?(:cljs (defn browser? [] (= cljs.core/*target* \"default\")))\n\n;(defmacro do-cljs [& body] (when (some? (:js-globals &env)) `(do ~@body)))\n\n; undocumented hack, only works in macros. https://stackoverflow.com/a/47499855\n#?(:clj (defn- cljs-target []\n          ; don't force app to :require clojurescript at runtime on the server\n          ; (It's okay if you do, it just means clojurescript must be on server classpath)\n          (let [compiler @(requiring-resolve 'cljs.env/*compiler*)]\n            (get-in @compiler [:options :closure-defines 'cljs.core/*target*]))))\n\n(defmacro do-nodejs  [& body] (if     (= \"nodejs\" (cljs-target)) `(do ~@body)))\n(defmacro do-browser [& body] (if-not (= \"nodejs\" (cljs-target)) `(do ~@body)))\n"]}