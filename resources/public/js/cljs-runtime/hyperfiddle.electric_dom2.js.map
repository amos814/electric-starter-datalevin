{"version":3,"sources":["hyperfiddle/electric_dom2.cljc"],"mappings":"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","names":["hyperfiddle.electric-dom2/nil-subject","!","var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","hyperfiddle.electric-dom2/unsupported","seq47716","self__5755__auto__","cljs.core/seq","_","cljs.core.ex_info","hyperfiddle.electric-dom2/hook","x","G__47717","y","hyperfiddle.electric-dom2/by-id","id","js/document.getElementById","hyperfiddle.electric-dom2/new-node","parent","type","el","G__47718","cljs.core/Keyword","js/document","goog.dom/createTextNode","goog.dom/createElement","hyperfiddle.electric-dom2/-googDomSetTextContentNoWarn","node","str","goog.dom/setTextContent","hyperfiddle.electric-dom2/class-str","v","cljs.core/name","clojure.string.join","cljs.core.eduction","cljs.core.remove","cljs.core/nil?","cljs.core.map","hyperfiddle.electric-dom2/SVG-NS","hyperfiddle.electric-dom2/XLINK-NS","hyperfiddle.electric-dom2/alias->ns","hyperfiddle.electric-dom2/attr-alias","attr","cljs.core/second","cljs.core/re-find","hyperfiddle.electric-dom2/resolve-attr-alias","temp__5802__auto__","alias","clojure.string/replace-first","G__47720","hyperfiddle.electric-dom2/set-attribute-ns","js/Error","vec__47721","cljs.core.nth","ns","hyperfiddle.electric_dom2.set_attribute_ns","G__47725","hyperfiddle.electric-dom2/set-property!","k","hyperfiddle.electric_dom2.set_property_BANG_","cljs.core/clj->js","and__5043__auto__","G__47726","goog.style/setStyle","hyperfiddle.electric_dom2.goog$module$goog$object.get","goog.dom/DIRECT_ATTRIBUTE_MAP_","cljs.core._EQ_","hyperfiddle.electric_dom2.goog$module$goog$object.containsKey","hyperfiddle.electric_dom2.goog$module$goog$object.set","hyperfiddle.electric-dom2/unmount-prop","missionary.core/observe","hyperfiddle.electric-dom2/listen","hyperfiddle.electric/-listen","hyperfiddle.electric-dom2/event*","hyperfiddle.electric/event*","hyperfiddle.electric-dom2/happen","s","e","G__47729","hyperfiddle.electric-dom2/set-val"],"sourcesContent":["(ns hyperfiddle.electric-dom2\n  (:refer-clojure :exclude [time])\n  (:require #?(:cljs goog.dom)\n            #?(:cljs goog.object)\n            #?(:cljs goog.style)\n            [hyperfiddle.electric :as e]\n            [missionary.core :as m]\n            [clojure.string :as str])\n  (:import [hyperfiddle.electric Pending])\n  #?(:cljs (:require-macros [hyperfiddle.electric-dom2 :refer [with]])))\n\n(e/def node)\n(def nil-subject (fn [!] (! nil) #()))\n(e/def keepalive (new (m/observe nil-subject)))\n\n(defn unsupported [& _]\n  (throw (ex-info (str \"Not available on this peer.\") {})))\n\n(def hook \"See `with`\"\n  #?(:clj  unsupported\n     :cljs (fn ([x] (some-> (.-parentNode x) (.removeChild x)))\n             ([x y] (.insertBefore (.-parentNode x) x y))))) ; rotate siblings\n\n(defmacro with\n  \"Attach `body` to a dom node, which will be moved in the DOM when body moves in the DAG.\n  Given p/for semantics, `body` can only move sideways or be cancelled. If body is cancelled,\n  the node will be unmounted. If body moves, the node will rotate with its siblings.\"\n  [dom-node & body]\n  `(binding [node ~dom-node]\n     ; wrap body in a constant frame, so it can be moved as a block\n     (new (e/hook hook node (e/fn [] keepalive ~@body))))) ; todo remove\n\n#?(:cljs (defn by-id [id] (js/document.getElementById id)))\n\n#?(:cljs\n   (defn new-node [parent type]\n     (let [el (case type\n                :comment (.createComment js/document \"\")\n                :text (goog.dom/createTextNode \"\")\n                (goog.dom/createElement type))]\n       (.appendChild parent el)\n       el)))\n\n(defmacro element [t & body]\n  `(with (new-node node ~(name t))\n     ; hack: speed up streamy unmount by removing from layout first\n     ; it also feels faster visually\n     (e/on-unmount #(set! (.. node -style -display) \"none\")) ; hack\n     ~@body))\n\n#?(:cljs (defn -googDomSetTextContentNoWarn [node str]\n           ; Electric says :infer-warning Cannot infer target type in expression, fixme\n           (goog.dom/setTextContent node str)))\n\n(defmacro text [& strs]\n  `(do (assert (not= (.-nodeType node) (.-TEXT_NODE node))\n               \"userland directed dom/text inside dom/text, which is illegal\")\n       ~@(map (fn [str]\n                `(with (new-node node :text)\n                   (-googDomSetTextContentNoWarn node ~str)))\n           strs)))\n\n(defmacro comment_ [& strs]\n  (cons `do\n    (map (fn [str] `(with (new-node node :comment)\n                      (-googDomSetTextContentNoWarn node ~str)))\n      strs)))\n\n(defn class-str [v]\n  (cond\n    (or (string? v) (keyword? v)) (name v)\n    (seq v) (clojure.string/join \" \" (eduction (remove nil?) (map name) v))\n    :else \"\"))\n\n(def ^:const SVG-NS \"http://www.w3.org/2000/svg\")\n(def ^:const XLINK-NS \"http://www.w3.org/1999/xlink\")\n\n(def alias->ns {\"svg\" SVG-NS, \"xlink\" XLINK-NS})\n\n(defn attr-alias [attr] (second (re-find #\"^([^:]+):\" (name attr))))\n\n(defn resolve-attr-alias [attr]\n  (let [attr (name attr)]\n    (if-let [alias (attr-alias attr)]\n      (let [attr (-> (str/replace-first attr alias \"\")\n                   (str/replace-first #\"^:\" \"\"))]\n        [(alias->ns alias) attr])\n      [nil attr])))\n\n#?(:cljs\n   (defn set-attribute-ns\n     ([node attr v]\n      (let [[ns attr] (resolve-attr-alias attr)]\n        (set-attribute-ns node ns attr v)))\n     ([^js node ns attr v]\n      (.setAttributeNS node ns attr v))))\n\n#?(:cljs\n   (defn set-property!\n     ([node k v] (set-property! node (.-namespaceURI node) k v))\n     ([node ns k v]\n      (let [k (name k)\n            v (clj->js v)]\n        (if (and (nil? v) (.hasAttributeNS node nil k))\n          (.removeAttributeNS node nil k)\n          (case k\n            \"style\" (goog.style/setStyle node v)\n            \"class\" (set-attribute-ns node nil \"class\" (class-str v))\n            \"list\"  (set-attribute-ns node nil k v) ; corner case, list (datalist) is setted by attribute and readonly as a prop.\n            (if-let [k (goog.object/get goog.dom/DIRECT_ATTRIBUTE_MAP_ k)]\n              (set-attribute-ns node k v)\n              (if (= SVG-NS ns)\n                (set-attribute-ns node k v)\n                (if (goog.object/containsKey node k) ; is there an object property for this key?\n                  (goog.object/set node k v)\n                  (set-attribute-ns node k v))))))))))\n\n#?(:cljs (defn unmount-prop [node k v]\n           (m/observe (fn [!] (! nil) #(set-property! node k v)))))\n\n(defmacro style [m]\n  (if (map? m)\n    `(do ~@(mapcat (fn [[k v]] [`(set-property! node \"style\" {~k ~v})\n                                `(new (unmount-prop node \"style\" {~k nil}))]) m)\n         nil) ; static keyset\n    `(e/for-by first [sty# (vec ~m)]\n       (set-property! node \"style\" {(key sty#) (val sty#)})\n       (new (unmount-prop node {(key sty#) nil}))\n       nil)))\n\n;; TODO JS runtimes intern litteral strings, so call `name` on keywords at\n;; macroexpension.\n(defmacro props [m]\n  (let [style? #{:style ::style}]       ; TODO disambiguate\n    (if (map? m)\n      `(do ~@(mapcat (fn [[k v]] (if (style? k) ; static keyset\n                                   [`(style ~v)]\n                                   [`(set-property! node ~k ~v)\n                                    `(new (unmount-prop node ~k nil))]))\n                     m)\n           nil)\n      `(e/for-by key [prop# (vec ~m)]\n         (if (~style? (key prop#))\n           (style (val prop#))\n           (do (set-property! node (key prop#) (val prop#))\n               (new (unmount-prop node (key prop#) nil))\n               nil))))))\n\n#?(:cljs (def listen e/-listen)) ; private\n#?(:cljs (def event* e/event*))\n\n(defmacro on!\n  \"Call the `callback` clojure function on event.\n   (on! \\\"click\\\" (fn [event] ...)) \"\n  ([event-name callback] `(on! node ~event-name ~callback))\n  ([dom-node event-name callback] `(on! ~dom-node ~event-name ~callback nil))\n  ([dom-node event-name callback options] `(new (event* ~dom-node ~event-name ~callback ~options))))\n\n(defn happen [s e]\n  ; Todo, we need a buffer (unbounded) to force a nil in between overlapping events to fix race\n  ; Buffer is unbounded because all events matter. (This is sequential unbounded queue)\n  (case (:status s)\n    :idle {:status :impulse :event e} ; rising edge\n    :pending {:status :impulse :event e} ; supersede the outstanding event with a new event\n    :impulse (assert false \"two events in the same frame? that's weird and wrong\")))\n\n; data EventState = Idle | Impulse event | Pending event\n(e/defn Event [type busy]\n  (:event\n    (let [!state (atom {:status :idle})\n          state (e/watch !state)]\n\n      ; rising edge happens once, even if busy state (prevent infinite loop) -- [DJG] I don't understand\n      (on! type (partial swap! !state happen)) ; discrete rising edge\n\n      (reset! !state\n              (case (:status state)\n                :idle state\n                :impulse (assoc state :status :pending) ; impulse is seen for 1 frame and then cleared\n                :pending (if busy state {:status :idle}))))))\n\n(defmacro ^:deprecated ^:no-doc event \"Deprecated, please use `on!`\" [& args] `(on! ~@args))\n(e/def ^:deprecated system-time-ms e/system-time-ms)\n(e/def ^:deprecated system-time-secs e/system-time-secs)\n\n(defmacro on\n  \"Run the given electric function on event.\n  (on \\\"click\\\" (e/fn [event] ...))\"\n  ;; TODO add support of event options (see `event*`)\n  ([typ]   `(new Event ~typ false))\n  ([typ F] `(on node ~typ ~F))\n  ([node typ F] `(binding [node ~node]\n                   ;; checking types is not enough, one could return an exception without throwing\n                   (let [[state# v#] (e/with-cycle [x# [::init nil]]\n                                       (if-some [evt# (new Event ~typ (= (first x#) ::pending))]\n                                         (try [::ok (new ~F evt#)]\n                                              (catch Pending  e# [::pending e#])\n                                              (catch :default e# [::err e#]))\n                                         x#))]\n                     (case state# (::init ::ok) v#, (::err ::pending) (throw v#))))))\n\n#?(:cljs (e/def visibility-state \"'hidden' | 'visible'\"\n           (new (->> (event* js/document \"visibilitychange\" identity {}) \n                  (m/latest #(.-visibilityState js/document))))))\n\n(defmacro on-pending [pending-body & body] `(try (do ~@body) (catch Pending e# ~pending-body (throw e#))))\n\n(e/defn Focused? []\n  (e/with-cycle [focused false]\n    (if focused (nil? (on \"blur\")) (some? (on \"focus\")))))\n\n#?(:cljs (defn set-val [node v] (set! (.-value node) (str v))))\n\n(defmacro bind-value\n  ([v]        `(bind-value ~v set-val))\n  ([v setter] `(when-some [v# (when-not (new Focused?) ~v)]\n                 (~setter node v#))))\n\n(defmacro a [& body] `(element :a ~@body))\n(defmacro abbr [& body] `(element :abbr ~@body))\n(defmacro address [& body] `(element :address ~@body))\n(defmacro area [& body] `(element :area ~@body))\n(defmacro article [& body] `(element :article ~@body))\n(defmacro aside [& body] `(element :aside ~@body))\n(defmacro audio [& body] `(element :audio ~@body))\n(defmacro b [& body] `(element :b ~@body))\n(defmacro bdi [& body] `(element :bdi ~@body))\n(defmacro bdo [& body] `(element :bdo ~@body))\n(defmacro blockquote [& body] `(element :blockquote ~@body))\n(defmacro br [& body] `(element :br ~@body))\n(defmacro button [& body] `(element :button ~@body))\n(defmacro canvas [& body] `(element :canvas ~@body))\n(defmacro cite [& body] `(element :cite ~@body))\n(defmacro code [& body] `(element :code ~@body))\n(defmacro data [& body] `(element :data ~@body))\n(defmacro datalist [& body] `(element :datalist ~@body))\n(defmacro del [& body] `(element :del ~@body))\n(defmacro details [& body] `(element :details ~@body))\n(defmacro dfn [& body] `(element :dfn ~@body))\n(defmacro dialog [& body] `(element :dialog ~@body))\n(defmacro div [& body] `(element :div ~@body))\n(defmacro dl \"The <dl> HTML element represents a description list. The element encloses a list of groups of terms (specified using the <dt> element) and descriptions (provided by <dd> elements). Common uses for this element are to implement a glossary or to display metadata (a list of key-value pairs).\" [& body] `(element :dl ~@body))\n(defmacro dt \"The <dt> HTML element specifies a term in a description or definition list, and as such must be used inside a <dl> element. It is usually followed by a <dd> element; however, multiple <dt> elements in a row indicate several terms that are all defined by the immediate next <dd> element.\" [& body] `(element :dt ~@body))\n(defmacro dd \"The <dd> HTML element provides the description, definition, or value for the preceding term (<dt>) in a description list (<dl>).\" [& body] `(element :dd ~@body))\n(defmacro em [& body] `(element :em ~@body))\n(defmacro embed [& body] `(element :embed ~@body))\n(defmacro fieldset [& body] `(element :fieldset ~@body))\n(defmacro figure [& body] `(element :figure ~@body))\n(defmacro footer [& body] `(element :footer ~@body))\n(defmacro form [& body] `(element :form ~@body))\n(defmacro h1 [& body] `(element :h1 ~@body))\n(defmacro h2 [& body] `(element :h2 ~@body))\n(defmacro h3 [& body] `(element :h3 ~@body))\n(defmacro h4 [& body] `(element :h4 ~@body))\n(defmacro h5 [& body] `(element :h5 ~@body))\n(defmacro h6 [& body] `(element :h6 ~@body))\n(defmacro header [& body] `(element :header ~@body))\n(defmacro hgroup [& body] `(element :hgroup ~@body))\n(defmacro hr [& body] `(element :hr ~@body))\n(defmacro i [& body] `(element :i ~@body))\n(defmacro iframe [& body] `(element :iframe ~@body))\n(defmacro img [& body] `(element :img ~@body))\n(defmacro input [& body] `(element :input ~@body))\n(defmacro ins [& body] `(element :ins ~@body))\n(defmacro kbd [& body] `(element :kbd ~@body))\n(defmacro label [& body] `(element :label ~@body))\n(defmacro legend [& body] `(element :legend ~@body))\n(defmacro li [& body] `(element :li ~@body))\n(defmacro link [& body] `(element :link ~@body))\n(defmacro main [& body] `(element :main ~@body))\n#_(defmacro map [& body] `(element :map ~@body))\n(defmacro mark [& body] `(element :mark ~@body))\n(defmacro math [& body] `(element :math ~@body))\n(defmacro menu [& body] `(element :menu ~@body))\n(defmacro itemprop [& body] `(element :itemprop ~@body))\n(defmacro meter [& body] `(element :meter ~@body))\n(defmacro nav [& body] `(element :nav ~@body))\n(defmacro noscript [& body] `(element :noscript ~@body))\n(defmacro object [& body] `(element :object ~@body))\n(defmacro ol [& body] `(element :ol ~@body))\n(defmacro option [& body] `(element :option ~@body))\n(defmacro optgroup [& body] `(element :optgroup ~@body))\n(defmacro output [& body] `(element :output ~@body))\n(defmacro p [& body] `(element :p ~@body))\n(defmacro picture [& body] `(element :picture ~@body))\n(defmacro pre [& body] `(element :pre ~@body))\n(defmacro progress [& body] `(element :progress ~@body))\n(defmacro q [& body] `(element :q ~@body))\n(defmacro ruby [& body] `(element :ruby ~@body))\n(defmacro s [& body] `(element :s ~@body))\n(defmacro samp [& body] `(element :samp ~@body))\n(defmacro script [& body] `(element :script ~@body))\n(defmacro section [& body] `(element :section ~@body))\n(defmacro select [& body] `(element :select ~@body))\n(defmacro slot [& body] `(element :slot ~@body))\n(defmacro small [& body] `(element :small ~@body))\n(defmacro span [& body] `(element :span ~@body))\n(defmacro strong [& body] `(element :strong ~@body))\n(defmacro sub [& body] `(element :sub ~@body))\n(defmacro summary [& body] `(element :summary ~@body))\n(defmacro sup [& body] `(element :sup ~@body))\n(defmacro table [& body] `(element :table ~@body))\n(defmacro tbody [& body] `(element :tbody ~@body))\n(defmacro td [& body] `(element :td ~@body))\n(defmacro th [& body] `(element :th ~@body))\n(defmacro thead [& body] `(element :thead ~@body))\n(defmacro tr [& body] `(element :tr ~@body))\n(defmacro template [& body] `(element :template ~@body))\n(defmacro textarea [& body] `(element :textarea ~@body))\n(defmacro time [& body] `(element :time ~@body))\n(defmacro u [& body] `(element :u ~@body))\n(defmacro ul [& body] `(element :ul ~@body))\n(defmacro var [& body] `(element :var ~@body))\n(defmacro video [& body] `(element :video ~@body))\n(defmacro wbr [& body] `(element :wbr ~@body))\n"]}