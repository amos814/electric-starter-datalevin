{"version":3,"sources":["cloroutine/core.cljc"],"mappings":"","names":[],"sourcesContent":["(ns cloroutine.core (:require [cloroutine.impl :as i]))\n\n(defmacro\n  ^{:arglists '([breaks & body]) :doc \"\nBuilds a coroutine evaluating body (in an implicit do), suspending evaluation at\ncall sites defined in the breaks map. The breaks map associates suspend vars to\nresume vars, both given as fully-qualified symbols.\n\nA coroutine is a stateful zero-arity function. Calling a coroutine in initial or\nsuspended state starts or resumes evaluation and returns the result of the next\nencountered suspend var call or final body expression.\n\nAfter calling a suspend var, the coroutine is in suspended state. A subsequent\ncoroutine call will resume body evaluation, the result of the suspend var call\nbeing substituted with the result of calling its associated resume var with zero\nargument.\n\nAfter reaching final body expression, or getting an uncaught exception, the\ncoroutine is in terminated state. Subsequent calls have undefined behavior.\n\nThe state of a coroutine is not synchronized, each call to a suspend var is\nexpected to happen-before its associated coroutine resume call.\n\nSuspend and resume vars are guaranteed to be called synchronously in the thread\ncalling the coroutine. For this reason, the cr macro will ignore breaking vars\nin code able to escape synchronous execution context. This includes function\nbodies and custom type methods.\n\nCalling the non-zero arity of a coroutine will clone the coroutine and pass the\ncopy to the function provided as first argument, and return the result. Other\narguments are passed to the function as-is.\n\"} cr [breaks & body]\n  (i/compile (gensym \"cr\") breaks &env (cons `do body)))\n"]}